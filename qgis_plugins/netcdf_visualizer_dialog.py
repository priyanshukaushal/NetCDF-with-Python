# -*- coding: utf-8 -*-
"""
/***************************************************************************
 netcdf_visualizerDialog
                                 A QGIS plugin
 converts netcdf data to raster data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-03-11
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Priyanshu Kaushal
        email                : priyanshu.kaushal2001@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from PyQt5.QtCore import QTimer
from PyQt5.QtWidgets import QAction, QFileDialog
from qgis.core import QgsProject, QgsRasterLayer
import gdal
from gdalconst import *
from osgeo import osr,ogr
import netCDF4 as nc
import numpy as np
import math
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'netcdf_visualizer_dialog_base.ui'))


class netcdf_visualizerDialog(QtWidgets.QDialog, FORM_CLASS):

    def __init__(self, parent=None):
        """Constructor."""
        super(netcdf_visualizerDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.comboBox.setEnabled(False)
        self.input_browse_button.clicked.connect(self.read_input)
        self.output_browse_button.clicked.connect(self.read_output)
        self.ok_button.clicked.connect(self.onclick_ok)
        self.cancel_button.clicked.connect(self.onclick_cancel)

    def read_input(self):
        input_path = QFileDialog.getOpenFileName(self, 'Open netCDF file', '','Network Common Data Format(*.nc *.NC)')
        if input_path == ('', ''):
            return
        else:
            self.input_line_edit.setText(input_path[0])
        ncfile = nc.Dataset(input_path[0], "r")
        vars_list = list(ncfile.variables)
        self.fill_combo_box(vars=vars_list, ncfile=ncfile)
        
    def fill_combo_box(self, vars, ncfile):
        self.comboBox.setEnabled(True)
        for i in vars:
            self.comboBox.addItem(i)

    def hsv_to_rgb(self, hue, saturation, intensity):  
        h60 = hue / 60.0
        h60f = math.floor(h60)
        hi = int(h60f) % 6
        f = h60 - h60f
        p = intensity * (1 - saturation)
        q = intensity * (1 - f * saturation)
        t = intensity * (1 - (1 - f) * saturation)
        r, g, b = 0, 0, 0
        if hi == 0: 
            r, g, b = intensity, t, p
        elif hi == 1:
            r, g, b = q, intensity, p
        elif hi == 2:
            r, g, b = p, intensity, t
        elif hi == 3:
            r, g, b = p, q, intensity
        elif hi == 4:
            r, g, b = t, p, intensity
        elif hi == 5:
            r, g, b = intensity, p, q
        return r,g,b


    def create_geotiff(self, ncfile, output_path, target_var, num_levels):
        if(ncfile == None or output_path == "" or target_var == "" or num_levels == ""):
            return
        self.ok_button.setEnabled(False)
        num_levels = int(num_levels)
        lat_name = "lat"
        lon_name = "lon"
        for i in list(ncfile.variables):
            if i.lower().find("lat") != -1:
                lat_name = i
            if i.lower().find("lon") != -1:
                lon_name = i
        lat = ncfile.variables[lat_name][:]
        lon = ncfile.variables[lon_name][:]
        target = ncfile.variables[target_var][:]
        shp = target.shape
        for i in range(len(shp)):
            if shp[i] != len(lat) and shp[i] != len(lon):
                for j in range(shp[i]-1, 0, -1):
                    target = np.delete(target,j,i)
                target = target.squeeze()
        target = target[::-1,:]
        target = target.data
        lon = ((lon+180) % 360) - 180

        nx = len(lon)
        ny = len(lat)
        xmin, ymin, xmax, ymax = [lon.min(), lat.min(), lon.max(), lat.max()]
        xres = (xmax - xmin) / float(nx)
        yres = (ymax - ymin) / float(ny)
        geotransform = (xmin, xres, 0, ymax, 0, -yres)


        mi = target.min()
        ma = target.max()
        new_ma = 0
        new_mi = 1000
        ndv = ncfile.variables[target_var]._FillValue
        target_scaled = np.zeros((target.shape))
        for i in range(0, len(target)):
            for j in range(0, len(target[i])):
                curr = target[i][j]
                if curr != ndv:     
                    target_scaled[i][j] = (((curr - mi) * 255) / (ma-mi)) + 0
                else :
                    target_scaled[i][j] = curr
                if target_scaled[i][j] != ndv and target_scaled[i][j] < new_mi:
                    new_mi = target_scaled[i][j]
                if target_scaled[i][j] != ndv and target_scaled[i][j] > new_ma:
                    new_ma = target_scaled[i][j]

        red = np.zeros((target_scaled.shape))
        green = np.zeros((target_scaled.shape))
        blue = np.zeros((target_scaled.shape))
        tave_range = new_ma - new_mi
        lut = np.zeros(num_levels+1)
        lut[1] = new_mi
        lut[num_levels] = new_ma

        for i in range(2, num_levels):
            lut[i] = lut[i-1] + (tave_range/num_levels)

        for i in range(0, len(target_scaled)):
            for j in range(0, len(target_scaled[i])):
                curr = target_scaled[i][j]
                if curr != ndv:
                    for k in range(1, num_levels):
                        if (curr >= lut[k] and curr < lut[k+1]):
                            h = (k/num_levels)*360
                            s = 1.0
                            v = 1.0
                            r,g,b = self.hsv_to_rgb(h,s,v)
                            red[i][j] = r
                            green[i][j] = g
                            blue[i][j] = b
                else :
                    red[i][j] = ndv
                    green[i][j] = ndv
                    blue[i][j] = ndv

        driver = gdal.GetDriverByName('GTiff')
        dst_ds = driver.Create(output_path, nx, ny, 3, gdal.GDT_Float32)
        dst_ds.SetGeoTransform(geotransform)    # specify coords
        dst_ds.GetRasterBand(1).SetNoDataValue(float(ndv)) #optional if no-data transparent
        dst_ds.GetRasterBand(2).SetNoDataValue(float(ndv))
        dst_ds.GetRasterBand(3).SetNoDataValue(float(ndv))
        dst_ds.GetRasterBand(1).WriteArray(red)
        dst_ds.GetRasterBand(2).WriteArray(blue)
        dst_ds.GetRasterBand(3).WriteArray(green)
        srs = osr.SpatialReference()            # establish encoding
        # srs.ImportFromEPSG(3857)                # WGS84 lat/long
        srs.SetWellKnownGeogCS("WGS84")
        dst_ds.SetProjection(srs.ExportToWkt()) # export coords to file
        dst_ds = None
        filelayer = QgsRasterLayer(output_path,os.path.basename(output_path))
        QgsProject.instance().addMapLayer(filelayer)
        self.ok_button.setEnabled(True)

        

    def onclick_ok(self):
        if(str(self.input_line_edit.text()) == ""):
            return
        ncfile = nc.Dataset(self.input_line_edit.text(), "r")
        self.create_geotiff(ncfile, str(self.output_line_edit.text()), str(self.comboBox.currentText()), str(self.num_levels.text()))
        self.input_line_edit.setText("")
        self.output_line_edit.setText("")
        self.num_levels.setText("")
        for i in range(self.comboBox.count()):
            self.comboBox.removeItem(0)
        self.comboBox.setEnabled(False)
        self.close()
    
    def onclick_cancel(self):
        self.input_line_edit.setText("")
        self.output_line_edit.setText("")
        self.num_levels.setText("")
        for i in range(self.comboBox.count()):
            self.comboBox.removeItem(0)
        self.comboBox.setEnabled(False)
        self.close()
        
    
    def read_output(self):
        output_path = QFileDialog.getOpenFileName(self, 'Save raster as', '','Geotif(*.tif)')
        if output_path == ('', ''):
            return
        else:
            self.output_line_edit.setText(output_path[0])